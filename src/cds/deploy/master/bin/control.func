#!/bin/bash
#wanghao
#wanghao01@baidu.com

#Start脚本标准流程：
#1、检查进程是否存在，如已存在，返回AOS_ERR_STARTED
#2、启动模块，如果启动过程中出现问题（无权限、缺少文件、超时），返回对应的错误码
#3、循环调用healthcheck，直到返回AOS_OK或AOS_ERR_NOT_WORKING或超时,将healthchenck脚本的返回值返回
function start
{
	#### <step 1> ####
	check_proc_exist "${PROC_NAME}"
	RET=$?
	if [ ${RET} == ${OK} ];then
		return ${AOS_ERR_STARTED}
	fi
    
    ## mkdir if necessary
    if [ ! -d ${STA_DIR} ];then
        mkdir ${STA_DIR}
    fi
    if [ ! -d ${LOG_DIR} ];then
        mkdir ${LOG_DIR}
    fi

	#### <step 2> ####
	#check the file access that started by command 
	#to make sure the command below can run normally
	if [ ! -d ${BIN_DIR} ];then
		return ${AOS_ERR_FILE_NOTFOUND}
	elif [ ! -f ${BIN_DIR}/${PROC_NAME} ];then
		return ${AOS_ERR_FILE_NOTFOUND}
	elif [ ! -x ${BIN_DIR}/${PROC_NAME} ];then
		return ${AOS_ERR_ACCESS}
	elif [ ! -d ${STA_DIR} -o ! -d ${CNF_DIR} ];then
		return ${AOS_ERR_FILE_NOTFOUND}
	elif [ ! -f ${CNF_DIR}/${PROC_CONF} ];then
		return ${AOS_ERR_FILE_NOTFOUND}
    fi

    cd ${TOP_PATH}
    file_size1=`stat  -c "%s" ${LOG_DIR}/master.log`
	$(eval ${START_COMMAND} &>${LOG_DIR}/${CONTROL_LOG} &)
	RET=$?
	cd - 1>/dev/null

	if [ ${RET} != ${OK} ];then
		return ${AOS_ERR_FAILED_OPERATION}
	fi

	#### <step 3> ####
	WAIT_TIME=0
	while [ 1 ]
	do
		#time out
		if [ ${WAIT_TIME} -gt ${MAX_HEC_TME} ];then
			return ${AOS_ERR_TIMEOUT}
		fi
		((WAIT_TIME++))

        #healthcheck until "AOS_OK" or "AOS_ERR_NOT_WORKING" 
        healthcheck $file_size1
        RET=$?
		
		if [ ${RET} == ${AOS_ERR_FAILED_OPERATION} ];then
			sleep 1
			continue
		elif [ ${RET} == ${AOS_ERR_NOT_WORKING} ];then
			return ${AOS_ERR_NOT_WORKING}
		elif [ ${RET} == ${AOS_OK} ];then
			return ${AOS_OK}	
		fi
    done
}

#Stop脚本标准流程：
#1、检查进程是否存在，如不存在，返回AOS_ERR_NOT_STARTED
#2、停止模块，如果停止过程中出现问题（无权限、缺少文件、超时），返回对应的错误码
#3、检查模块进程是否存在，如仍存在，返回AOS_ERR_FAILED_OPERATION
#4、进行该模块的额外检查，如有问题，返回AOS_ERR_FAILED_OPERATION
#5、返回AOS_OK
function stop
{
	#### <step 1> ####
	check_proc_exist "${PROC_NAME}"
	RET=$?
	if [ ${RET} != ${OK} ];then
	    return ${AOS_ERR_NOT_STARTED}
	fi

	#### <step 2> ####
	${STOP_COMMAND}

	# wait MAX_WAT_TME * 100 secondes
	for((i = 0; i <= 100; i++))
	do
		sleep ${MAX_WAT_TME}

		#### <step 3> ####
		check_proc_exist "${PROC_NAME}"
		RET=$?
		if [ ${RET} == ${OK} ]; then
			# process exists, continue wait
			continue;
		else
			#### <step 5> ####
			return ${AOS_OK} 
		fi
	done
	
	return ${AOS_ERR_FAILED_OPERATION}
}

#Restart脚本标准流程A：
#1、调用stop脚本，如未返回AOS_OK，则将该脚本的返回值返回
#2、调用start脚本，将该脚本的返回值返回
function restart
{
#	killall -9 ${PROC_NAME}
	#### <step 1> ####
	stop;
	RET=$?
	if [ ${RET} != ${OK} ];then
		return ${RET}
	fi

	#### <step 2> ####
	start;
	RET=$?
	return ${RET}
}

#Cleanup脚本标准流程：
#1、清理资源，如果清理过程中出现问题（无权限、缺少文件、超时），返回对应的错误码
#2、检查模块进程是否存在，如仍存在，返回AOS_ERR_FAILED_OPERATION
#3、进行该模块的额外检查，如有问题，返回AOS_ERR_FAILED_OPERATION
#4、返回AOS_OK
function cleanup
{
	#### <step 1> ####
	${STOP_COMMAND}
	sleep ${MAX_WAT_TME}

	#### <step 2> ####
	check_proc_exist "${PROC_NAME}"
	RET=$?
	if [ ${RET} == ${OK} ];then
	    return ${AOS_ERR_FAILED_OPERATION}
	fi

	#### <step 4> ####
	return ${AOS_OK}
}

function check_log_roll
{
	local time_limit log_name i j k this_time last_time
	local last[168] day hour
	if [ $# -ne 2 ];then
		return 1
	fi
	if [ ! -r $1 ];then
		return 1
	fi
	if [ $2 -gt 0 2>/dev/null ];then
		time_limit=$2
	else
		return 1
	fi
	log_name=$1

	for((j=0;j<168;j++))
	do
		day=$[$j/24]
		hour=$[$j%24]
		if [ $hour -lt 10 ]; then
			hour="0"$hour
		fi
		if [ -f $log_name/$day/chunkserver.$hour ]; then
			last[j]=`date +%s -r $log_name/$day/chunkserver.$hour`
		else
			last[j]=0
		fi
	done
	
	for((i=0;i<=time_limit;i++))
	do
		for((j=0;j<168;j++))
		do
			day=$[$j/24]
			hour=$[$j%24]
			if [ $hour -lt 10 ]; then
				hour="0"$hour
			fi	
			if [ -f $log_name/$day/chunkserver.$hour ]; then
				this_time=`date +%s -r $log_name/$day/chunkserver.$hour`
				if [ $this_time -gt ${last[j]} ]; then
					return 0
				fi
			fi
		done
		sleep 1
	done
	return 1
}


#Healthcheck脚本标准流程：
#1、检查（监听某端口的）进程是否存在，如不存在，返回AOS_ERR_FAILED_OPERATION
#2、检查线程数是否大于指定值，如不满足，返回AOS_ERR_FAILED_OPERATION
#3、进行该模块的特性检查，如有问题，返回AOS_ERR_FAILED_OPERATION
#4、检查日志是否正常滚动，如不滚动，返回AOS_ERR_NOT_WORKING
#5、返回AOS_OK

function healthcheck
{
	#### <step 1> ####
	if [ "${CHK_PROC_EXIST}" == "1" ];then
		check_proc_exist "${PROC_NAME}"
		RET=$?
		if [ ${RET} != ${OK} ];then
		    return ${AOS_ERR_FAILED_OPERATION}
		fi
	fi

	#### <step 2> ####
	if [ "${CHK_PROC_NUM}" == "1" ];then
		check_proc_num "${PROC_NAME}" "${TRD_NUM}"
		RET=$?
		if [ ${RET} != ${OK} ];then
			return ${AOS_ERR_FAILED_OPERATION}
		fi
    fi

    #### <step 3> ####
#	if [ "${CHK_LOG_KEY_WORD}" == "1" ];then
#        if [ $# -eq 1 ];then
#            file_size2=`stat  -c "%s" ${LOG_DIR}/${PROC_NAME}.log`
#            dis=`expr $file_size2 - $1`
#            tail -c $dis ${LOG_DIR}/${PROC_NAME}.log | grep "${LOG_KEY_WORD}" | grep -v "sync_server" >/dev/null
#            RET=$?
#        fi
#		if [ ${RET} != ${OK} ];then
#			return ${AOS_ERR_FAILED_OPERATION}
#		fi
 #   fi

	#### <step 4> ####
#	if [ "${CHK_LOG_ROLL}" == "1" ];then
#		#重新加载control.conf, 减少日志检查失败的情况
#		source ${TOP_PATH}/conf/control.conf || return ${AOS_ERR_FILE_NOTFOUND}
#		unset include_path
#		check_log_roll "${LOG_DIR}/" ${LOG_CHK_TME}
#		RET=$?
#		if [ ${RET} != ${OK} ];then
#			return ${AOS_ERR_NOT_WORKING}
#		fi
#	fi

	#### <step 5> ####
	return ${AOS_OK}
}

#Reload脚本标准流程B：
#1、检查进程是否存在，如不存在，返回AOS_ERR_NOT_STARTED
#2、重载配置，如果重载过程中出现问题（无权限、缺少文件、超时），返回对应的错误码
#3、循环调用healthcheck，直到返回AOS_OK或AOS_ERR_NOT_WORKING或超时,将healthchenck脚本的返回值返回
function reload
{
	RELOAD="$*"
	#### <step 1> ####
	check_proc_exist "${PROC_NAME}"
	RET=$?
	if [ ${RET} != ${OK} ];then
		return ${AOS_ERR_NOT_STARTED}
	fi

	#### <step 2> ####
	cd ${TOP_PATH}
	${BIN_DIR}/${PROC_RELOAD_NAME} ${RELOAD} &>${LOG_DIR}/${CONTROL_LOG}
	RET=$?
	cd - 1>/dev/null

	if [ ${RET} != "0" ];then
		return ${AOS_ERR_FAILED_OPERATION}
	fi

	#### <step 3> ####
	WAIT_TIME=0
	while [ 1 ]
	do
		#time out
		if [ ${WAIT_TIME} -gt ${MAX_HEC_TME} ];then
			return ${AOS_ERR_TIMEOUT}
		fi
		((WAIT_TIME++))

		#healthcheck until "AOS_OK" or "AOS_ERR_NOT_WORKING" 
		healthcheck;
		RET=$?

		if [ ${RET} == ${AOS_ERR_FAILED_OPERATION} ];then
			sleep 1
			continue
		elif [ ${RET} == ${AOS_ERR_NOT_WORKING} ];then
			return ${AOS_ERR_NOT_WORKING}
		elif [ ${RET} == ${AOS_OK} ];then
			return ${AOS_OK}
		fi
	done
}
